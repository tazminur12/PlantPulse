import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js
var require_eslint_plugin_react_hooks_development = __commonJS({
  "node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m) return m.call(o);
          if (o && typeof o.length === "number") return {
            next: function() {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m) return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"])) m.call(i);
            } finally {
              if (e) throw e.error;
            }
          }
          return ar;
        }
        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
          return to.concat(ar || from);
        }
        function isHookName(s) {
          return s === "use" || /^use[A-Z0-9]/.test(s);
        }
        function isHook(node) {
          if (node.type === "Identifier") {
            return isHookName(node.name);
          } else if (node.type === "MemberExpression" && !node.computed && isHook(node.property)) {
            var obj = node.object;
            var isPascalCaseNameSpace = /^[A-Z].*/;
            return obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name);
          } else {
            return false;
          }
        }
        function isComponentName(node) {
          return node.type === "Identifier" && /^[A-Z]/.test(node.name);
        }
        function isReactFunction(node, functionName) {
          return "name" in node && node.name === functionName || node.type === "MemberExpression" && "name" in node.object && node.object.name === "React" && "name" in node.property && node.property.name === functionName;
        }
        function isForwardRefCallback(node) {
          return !!(node.parent && "callee" in node.parent && node.parent.callee && isReactFunction(node.parent.callee, "forwardRef"));
        }
        function isMemoCallback(node) {
          return !!(node.parent && "callee" in node.parent && node.parent.callee && isReactFunction(node.parent.callee, "memo"));
        }
        function isInsideComponentOrHook(node) {
          while (node) {
            var functionName = getFunctionName(node);
            if (functionName) {
              if (isComponentName(functionName) || isHook(functionName)) {
                return true;
              }
            }
            if (isForwardRefCallback(node) || isMemoCallback(node)) {
              return true;
            }
            node = node.parent;
          }
          return false;
        }
        function isInsideDoWhileLoop(node) {
          while (node) {
            if (node.type === "DoWhileStatement") {
              return true;
            }
            node = node.parent;
          }
          return false;
        }
        function isUseEffectEventIdentifier$1(node) {
          return false;
        }
        function isUseIdentifier(node) {
          return isReactFunction(node, "use");
        }
        var rule$1 = {
          meta: {
            type: "problem",
            docs: {
              description: "enforces the Rules of Hooks",
              recommended: true,
              url: "https://reactjs.org/docs/hooks-rules.html"
            }
          },
          create: function(context) {
            var lastEffect = null;
            var codePathReactHooksMapStack = [];
            var codePathSegmentStack = [];
            var useEffectEventFunctions = /* @__PURE__ */ new WeakSet();
            function recordAllUseEffectEventFunctions(scope) {
              var e_1, _a, e_2, _b;
              try {
                for (var _c = __values(scope.references), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var reference = _d.value;
                  var parent = reference.identifier.parent;
                  if ((parent === null || parent === void 0 ? void 0 : parent.type) === "VariableDeclarator" && parent.init && parent.init.type === "CallExpression" && parent.init.callee && isUseEffectEventIdentifier$1(parent.init.callee)) {
                    if (reference.resolved === null) {
                      throw new Error("Unexpected null reference.resolved");
                    }
                    try {
                      for (var _e = (e_2 = void 0, __values(reference.resolved.references)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var ref = _f.value;
                        if (ref !== reference) {
                          useEffectEventFunctions.add(ref.identifier);
                        }
                      }
                    } catch (e_2_1) {
                      e_2 = { error: e_2_1 };
                    } finally {
                      try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                      } finally {
                        if (e_2) throw e_2.error;
                      }
                    }
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            }
            var getSourceCode = typeof context.getSourceCode === "function" ? function() {
              return context.getSourceCode();
            } : function() {
              return context.sourceCode;
            };
            var getScope = typeof context.getScope === "function" ? function() {
              return context.getScope();
            } : function(node) {
              return getSourceCode().getScope(node);
            };
            return {
              // Maintain code segment path stack as we traverse.
              onCodePathSegmentStart: function(segment) {
                return codePathSegmentStack.push(segment);
              },
              onCodePathSegmentEnd: function() {
                return codePathSegmentStack.pop();
              },
              // Maintain code path stack as we traverse.
              onCodePathStart: function() {
                return codePathReactHooksMapStack.push(/* @__PURE__ */ new Map());
              },
              // Process our code path.
              //
              // Everything is ok if all React Hooks are both reachable from the initial
              // segment and reachable from every final segment.
              onCodePathEnd: function(codePath, codePathNode) {
                var e_3, _a, e_4, _b, e_5, _c;
                var reactHooksMap = codePathReactHooksMapStack.pop();
                if ((reactHooksMap === null || reactHooksMap === void 0 ? void 0 : reactHooksMap.size) === 0) {
                  return;
                } else if (typeof reactHooksMap === "undefined") {
                  throw new Error("Unexpected undefined reactHooksMap");
                }
                var cyclic = /* @__PURE__ */ new Set();
                function countPathsFromStart(segment2, pathHistory) {
                  var e_6, _a2, e_7, _b2;
                  var cache = countPathsFromStart.cache;
                  var paths = cache.get(segment2.id);
                  var pathList = new Set(pathHistory);
                  if (pathList.has(segment2.id)) {
                    var pathArray = __spreadArray([], __read(pathList), false);
                    var cyclicSegments = pathArray.slice(pathArray.indexOf(segment2.id) + 1);
                    try {
                      for (var cyclicSegments_1 = __values(cyclicSegments), cyclicSegments_1_1 = cyclicSegments_1.next(); !cyclicSegments_1_1.done; cyclicSegments_1_1 = cyclicSegments_1.next()) {
                        var cyclicSegment = cyclicSegments_1_1.value;
                        cyclic.add(cyclicSegment);
                      }
                    } catch (e_6_1) {
                      e_6 = { error: e_6_1 };
                    } finally {
                      try {
                        if (cyclicSegments_1_1 && !cyclicSegments_1_1.done && (_a2 = cyclicSegments_1.return)) _a2.call(cyclicSegments_1);
                      } finally {
                        if (e_6) throw e_6.error;
                      }
                    }
                    return BigInt("0");
                  }
                  pathList.add(segment2.id);
                  if (paths !== void 0) {
                    return paths;
                  }
                  if (codePath.thrownSegments.includes(segment2)) {
                    paths = BigInt("0");
                  } else if (segment2.prevSegments.length === 0) {
                    paths = BigInt("1");
                  } else {
                    paths = BigInt("0");
                    try {
                      for (var _c2 = __values(segment2.prevSegments), _d2 = _c2.next(); !_d2.done; _d2 = _c2.next()) {
                        var prevSegment = _d2.value;
                        paths += countPathsFromStart(prevSegment, pathList);
                      }
                    } catch (e_7_1) {
                      e_7 = { error: e_7_1 };
                    } finally {
                      try {
                        if (_d2 && !_d2.done && (_b2 = _c2.return)) _b2.call(_c2);
                      } finally {
                        if (e_7) throw e_7.error;
                      }
                    }
                  }
                  if (segment2.reachable && paths === BigInt("0")) {
                    cache.delete(segment2.id);
                  } else {
                    cache.set(segment2.id, paths);
                  }
                  return paths;
                }
                function countPathsToEnd(segment2, pathHistory) {
                  var e_8, _a2, e_9, _b2;
                  var cache = countPathsToEnd.cache;
                  var paths = cache.get(segment2.id);
                  var pathList = new Set(pathHistory);
                  if (pathList.has(segment2.id)) {
                    var pathArray = Array.from(pathList);
                    var cyclicSegments = pathArray.slice(pathArray.indexOf(segment2.id) + 1);
                    try {
                      for (var cyclicSegments_2 = __values(cyclicSegments), cyclicSegments_2_1 = cyclicSegments_2.next(); !cyclicSegments_2_1.done; cyclicSegments_2_1 = cyclicSegments_2.next()) {
                        var cyclicSegment = cyclicSegments_2_1.value;
                        cyclic.add(cyclicSegment);
                      }
                    } catch (e_8_1) {
                      e_8 = { error: e_8_1 };
                    } finally {
                      try {
                        if (cyclicSegments_2_1 && !cyclicSegments_2_1.done && (_a2 = cyclicSegments_2.return)) _a2.call(cyclicSegments_2);
                      } finally {
                        if (e_8) throw e_8.error;
                      }
                    }
                    return BigInt("0");
                  }
                  pathList.add(segment2.id);
                  if (paths !== void 0) {
                    return paths;
                  }
                  if (codePath.thrownSegments.includes(segment2)) {
                    paths = BigInt("0");
                  } else if (segment2.nextSegments.length === 0) {
                    paths = BigInt("1");
                  } else {
                    paths = BigInt("0");
                    try {
                      for (var _c2 = __values(segment2.nextSegments), _d2 = _c2.next(); !_d2.done; _d2 = _c2.next()) {
                        var nextSegment = _d2.value;
                        paths += countPathsToEnd(nextSegment, pathList);
                      }
                    } catch (e_9_1) {
                      e_9 = { error: e_9_1 };
                    } finally {
                      try {
                        if (_d2 && !_d2.done && (_b2 = _c2.return)) _b2.call(_c2);
                      } finally {
                        if (e_9) throw e_9.error;
                      }
                    }
                  }
                  cache.set(segment2.id, paths);
                  return paths;
                }
                function shortestPathLengthToStart(segment2) {
                  var e_10, _a2;
                  var cache = shortestPathLengthToStart.cache;
                  var length2 = cache.get(segment2.id);
                  if (length2 === null) {
                    return Infinity;
                  }
                  if (length2 !== void 0) {
                    return length2;
                  }
                  cache.set(segment2.id, null);
                  if (segment2.prevSegments.length === 0) {
                    length2 = 1;
                  } else {
                    length2 = Infinity;
                    try {
                      for (var _b2 = __values(segment2.prevSegments), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                        var prevSegment = _c2.value;
                        var prevLength = shortestPathLengthToStart(prevSegment);
                        if (prevLength < length2) {
                          length2 = prevLength;
                        }
                      }
                    } catch (e_10_1) {
                      e_10 = { error: e_10_1 };
                    } finally {
                      try {
                        if (_c2 && !_c2.done && (_a2 = _b2.return)) _a2.call(_b2);
                      } finally {
                        if (e_10) throw e_10.error;
                      }
                    }
                    length2 += 1;
                  }
                  cache.set(segment2.id, length2);
                  return length2;
                }
                countPathsFromStart.cache = /* @__PURE__ */ new Map();
                countPathsToEnd.cache = /* @__PURE__ */ new Map();
                shortestPathLengthToStart.cache = /* @__PURE__ */ new Map();
                var allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment);
                var codePathFunctionName = getFunctionName(codePathNode);
                var isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);
                var isDirectlyInsideComponentOrHook = codePathFunctionName ? isComponentName(codePathFunctionName) || isHook(codePathFunctionName) : isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode);
                var shortestFinalPathLength = Infinity;
                try {
                  for (var _d = __values(codePath.finalSegments), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var finalSegment = _e.value;
                    if (!finalSegment.reachable) {
                      continue;
                    }
                    var length = shortestPathLengthToStart(finalSegment);
                    if (length < shortestFinalPathLength) {
                      shortestFinalPathLength = length;
                    }
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                  } finally {
                    if (e_3) throw e_3.error;
                  }
                }
                try {
                  for (var reactHooksMap_1 = __values(reactHooksMap), reactHooksMap_1_1 = reactHooksMap_1.next(); !reactHooksMap_1_1.done; reactHooksMap_1_1 = reactHooksMap_1.next()) {
                    var _f = __read(reactHooksMap_1_1.value, 2), segment = _f[0], reactHooks = _f[1];
                    if (!segment.reachable) {
                      continue;
                    }
                    var possiblyHasEarlyReturn = segment.nextSegments.length === 0 ? shortestFinalPathLength <= shortestPathLengthToStart(segment) : shortestFinalPathLength < shortestPathLengthToStart(segment);
                    var pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment);
                    var cycled = cyclic.has(segment.id);
                    try {
                      for (var reactHooks_1 = (e_5 = void 0, __values(reactHooks)), reactHooks_1_1 = reactHooks_1.next(); !reactHooks_1_1.done; reactHooks_1_1 = reactHooks_1.next()) {
                        var hook = reactHooks_1_1.value;
                        if ((cycled || isInsideDoWhileLoop(hook)) && !isUseIdentifier(hook)) {
                          context.report({
                            node: hook,
                            message: 'React Hook "'.concat(getSourceCode().getText(hook), '" may be executed ') + "more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render."
                          });
                        }
                        if (isDirectlyInsideComponentOrHook) {
                          var isAsyncFunction = codePathNode.async;
                          if (isAsyncFunction) {
                            context.report({
                              node: hook,
                              message: 'React Hook "'.concat(getSourceCode().getText(hook), '" cannot be ') + "called in an async function."
                            });
                          }
                          if (!cycled && pathsFromStartToEnd !== allPathsFromStartToEnd && !isUseIdentifier(hook) && // `use(...)` can be called conditionally.
                          !isInsideDoWhileLoop(hook)) {
                            var message = 'React Hook "'.concat(getSourceCode().getText(hook), '" is called ') + "conditionally. React Hooks must be called in the exact same order in every component render." + (possiblyHasEarlyReturn ? " Did you accidentally call a React Hook after an early return?" : "");
                            context.report({ node: hook, message });
                          }
                        } else if (codePathNode.parent != null && (codePathNode.parent.type === "MethodDefinition" || // @ts-expect-error `ClassProperty` was removed from typescript-estree in https://github.com/typescript-eslint/typescript-eslint/pull/3806
                        codePathNode.parent.type === "ClassProperty" || codePathNode.parent.type === "PropertyDefinition") && codePathNode.parent.value === codePathNode) {
                          var message = 'React Hook "'.concat(getSourceCode().getText(hook), '" cannot be called ') + "in a class component. React Hooks must be called in a React function component or a custom React Hook function.";
                          context.report({ node: hook, message });
                        } else if (codePathFunctionName) {
                          var message = 'React Hook "'.concat(getSourceCode().getText(hook), '" is called in ') + 'function "'.concat(getSourceCode().getText(codePathFunctionName), '" ') + 'that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word "use".';
                          context.report({ node: hook, message });
                        } else if (codePathNode.type === "Program") {
                          var message = 'React Hook "'.concat(getSourceCode().getText(hook), '" cannot be called ') + "at the top level. React Hooks must be called in a React function component or a custom React Hook function.";
                          context.report({ node: hook, message });
                        } else {
                          if (isSomewhereInsideComponentOrHook && !isUseIdentifier(hook)) {
                            var message = 'React Hook "'.concat(getSourceCode().getText(hook), '" cannot be called ') + "inside a callback. React Hooks must be called in a React function component or a custom React Hook function.";
                            context.report({ node: hook, message });
                          }
                        }
                      }
                    } catch (e_5_1) {
                      e_5 = { error: e_5_1 };
                    } finally {
                      try {
                        if (reactHooks_1_1 && !reactHooks_1_1.done && (_c = reactHooks_1.return)) _c.call(reactHooks_1);
                      } finally {
                        if (e_5) throw e_5.error;
                      }
                    }
                  }
                } catch (e_4_1) {
                  e_4 = { error: e_4_1 };
                } finally {
                  try {
                    if (reactHooksMap_1_1 && !reactHooksMap_1_1.done && (_b = reactHooksMap_1.return)) _b.call(reactHooksMap_1);
                  } finally {
                    if (e_4) throw e_4.error;
                  }
                }
              },
              // Missed opportunity...We could visit all `Identifier`s instead of all
              // `CallExpression`s and check that _every use_ of a hook name is valid.
              // But that gets complicated and enters type-system territory, so we're
              // only being strict about hook calls for now.
              CallExpression: function(node) {
                if (isHook(node.callee)) {
                  var reactHooksMap = last(codePathReactHooksMapStack);
                  var codePathSegment = last(codePathSegmentStack);
                  var reactHooks = reactHooksMap.get(codePathSegment);
                  if (!reactHooks) {
                    reactHooks = [];
                    reactHooksMap.set(codePathSegment, reactHooks);
                  }
                  reactHooks.push(node.callee);
                }
                if (node.callee.type === "Identifier" && (node.callee.name === "useEffect" || isUseEffectEventIdentifier$1()) && node.arguments.length > 0) {
                  lastEffect = node;
                }
              },
              Identifier: function(node) {
                if (lastEffect == null && useEffectEventFunctions.has(node) && node.parent.type !== "CallExpression") {
                  context.report({
                    node,
                    message: "`".concat(getSourceCode().getText(node), '` is a function created with React Hook "useEffectEvent", and can only be called from ') + "the same component. They cannot be assigned to variables or passed down."
                  });
                }
              },
              "CallExpression:exit": function(node) {
                if (node === lastEffect) {
                  lastEffect = null;
                }
              },
              FunctionDeclaration: function(node) {
                if (isInsideComponentOrHook(node)) {
                  recordAllUseEffectEventFunctions(getScope(node));
                }
              },
              ArrowFunctionExpression: function(node) {
                if (isInsideComponentOrHook(node)) {
                  recordAllUseEffectEventFunctions(getScope(node));
                }
              }
            };
          }
        };
        function getFunctionName(node) {
          var _a, _b, _c, _d;
          if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression" && node.id) {
            return node.id;
          } else if (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "VariableDeclarator" && node.parent.init === node) {
              return node.parent.id;
            } else if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === "AssignmentExpression" && node.parent.right === node && node.parent.operator === "=") {
              return node.parent.left;
            } else if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type) === "Property" && node.parent.value === node && !node.parent.computed) {
              return node.parent.key;
            } else if (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type) === "AssignmentPattern" && node.parent.right === node && // @ts-expect-error Property computed does not exist on type `AssignmentPattern`.
            !node.parent.computed) {
              return node.parent.left;
            } else {
              return void 0;
            }
          } else {
            return void 0;
          }
        }
        function last(array) {
          return array[array.length - 1];
        }
        var rule = {
          meta: {
            type: "suggestion",
            docs: {
              description: "verifies the list of dependencies for Hooks like useEffect and similar",
              recommended: true,
              url: "https://github.com/facebook/react/issues/14920"
            },
            fixable: "code",
            hasSuggestions: true,
            schema: [
              {
                type: "object",
                additionalProperties: false,
                enableDangerousAutofixThisMayCauseInfiniteLoops: false,
                properties: {
                  additionalHooks: {
                    type: "string"
                  },
                  enableDangerousAutofixThisMayCauseInfiniteLoops: {
                    type: "boolean"
                  }
                }
              }
            ]
          },
          create: function(context) {
            var additionalHooks = context.options && context.options[0] && context.options[0].additionalHooks ? new RegExp(context.options[0].additionalHooks) : void 0;
            var enableDangerousAutofixThisMayCauseInfiniteLoops = context.options && context.options[0] && context.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops || false;
            var options = {
              additionalHooks,
              enableDangerousAutofixThisMayCauseInfiniteLoops
            };
            function reportProblem(problem) {
              if (enableDangerousAutofixThisMayCauseInfiniteLoops) {
                if (Array.isArray(problem.suggest) && problem.suggest.length > 0 && problem.suggest[0]) {
                  problem.fix = problem.suggest[0].fix;
                }
              }
              context.report(problem);
            }
            var getSourceCode = typeof context.getSourceCode === "function" ? function() {
              return context.getSourceCode();
            } : function() {
              return context.sourceCode;
            };
            var getScope = typeof context.getScope === "function" ? function() {
              return context.getScope();
            } : function(node) {
              return context.sourceCode.getScope(node);
            };
            var scopeManager = getSourceCode().scopeManager;
            var setStateCallSites = /* @__PURE__ */ new WeakMap();
            var stateVariables = /* @__PURE__ */ new WeakSet();
            var stableKnownValueCache = /* @__PURE__ */ new WeakMap();
            var functionWithoutCapturedValueCache = /* @__PURE__ */ new WeakMap();
            var useEffectEventVariables = /* @__PURE__ */ new WeakSet();
            function memoizeWithWeakMap(fn, map) {
              return function(arg) {
                if (map.has(arg)) {
                  return map.get(arg);
                }
                var result = fn(arg);
                map.set(arg, result);
                return result;
              };
            }
            function visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect) {
              var e_1, _a, e_2, _b, e_3, _c;
              if (isEffect && node.async) {
                reportProblem({
                  node,
                  message: "Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
                });
              }
              var scope = scopeManager.acquire(node);
              if (!scope) {
                throw new Error("Unable to acquire scope for the current node. This is a bug in eslint-plugin-react-hooks, please file an issue.");
              }
              var pureScopes = /* @__PURE__ */ new Set();
              var componentScope = null;
              {
                var currentScope = scope.upper;
                while (currentScope) {
                  pureScopes.add(currentScope);
                  if (currentScope.type === "function") {
                    break;
                  }
                  currentScope = currentScope.upper;
                }
                if (!currentScope) {
                  return;
                }
                componentScope = currentScope;
              }
              var isArray = Array.isArray;
              function isStableKnownHookValue(resolved2) {
                var e_4, _a2, e_5, _b2, e_6, _c2;
                if (!isArray(resolved2.defs)) {
                  return false;
                }
                var def2 = resolved2.defs[0];
                if (def2 == null) {
                  return false;
                }
                var defNode = def2.node;
                if (defNode.type !== "VariableDeclarator") {
                  return false;
                }
                var init = defNode.init;
                if (init == null) {
                  return false;
                }
                while (init.type === "TSAsExpression" || init.type === "AsExpression") {
                  init = init.expression;
                }
                var declaration = defNode.parent;
                if (declaration == null && componentScope != null) {
                  fastFindReferenceWithParent(componentScope.block, def2.node.id);
                  declaration = def2.node.parent;
                  if (declaration == null) {
                    return false;
                  }
                }
                if (declaration != null && "kind" in declaration && declaration.kind === "const" && init.type === "Literal" && (typeof init.value === "string" || typeof init.value === "number" || init.value === null)) {
                  return true;
                }
                if (init.type !== "CallExpression") {
                  return false;
                }
                var callee = init.callee;
                if (callee.type === "MemberExpression" && "name" in callee.object && callee.object.name === "React" && callee.property != null && !callee.computed) {
                  callee = callee.property;
                }
                if (callee.type !== "Identifier") {
                  return false;
                }
                var definitionNode = def2.node;
                var id2 = definitionNode.id;
                var name = callee.name;
                if (name === "useRef" && id2.type === "Identifier") {
                  return true;
                } else if (isUseEffectEventIdentifier() && id2.type === "Identifier") {
                  try {
                    for (var _d2 = __values(resolved2.references), _e = _d2.next(); !_e.done; _e = _d2.next()) {
                      var ref2 = _e.value;
                      if (ref2 !== id2) {
                        useEffectEventVariables.add(ref2.identifier);
                      }
                    }
                  } catch (e_4_1) {
                    e_4 = { error: e_4_1 };
                  } finally {
                    try {
                      if (_e && !_e.done && (_a2 = _d2.return)) _a2.call(_d2);
                    } finally {
                      if (e_4) throw e_4.error;
                    }
                  }
                  return true;
                } else if (name === "useState" || name === "useReducer" || name === "useActionState") {
                  if (id2.type === "ArrayPattern" && id2.elements.length === 2 && isArray(resolved2.identifiers)) {
                    if (id2.elements[1] === resolved2.identifiers[0]) {
                      if (name === "useState") {
                        var references2 = resolved2.references;
                        var writeCount = 0;
                        try {
                          for (var references_2 = __values(references2), references_2_1 = references_2.next(); !references_2_1.done; references_2_1 = references_2.next()) {
                            var reference2 = references_2_1.value;
                            if (reference2.isWrite()) {
                              writeCount++;
                            }
                            if (writeCount > 1) {
                              return false;
                            }
                            setStateCallSites.set(reference2.identifier, id2.elements[0]);
                          }
                        } catch (e_5_1) {
                          e_5 = { error: e_5_1 };
                        } finally {
                          try {
                            if (references_2_1 && !references_2_1.done && (_b2 = references_2.return)) _b2.call(references_2);
                          } finally {
                            if (e_5) throw e_5.error;
                          }
                        }
                      }
                      return true;
                    } else if (id2.elements[0] === resolved2.identifiers[0]) {
                      if (name === "useState") {
                        var references2 = resolved2.references;
                        try {
                          for (var references_3 = __values(references2), references_3_1 = references_3.next(); !references_3_1.done; references_3_1 = references_3.next()) {
                            var reference2 = references_3_1.value;
                            stateVariables.add(reference2.identifier);
                          }
                        } catch (e_6_1) {
                          e_6 = { error: e_6_1 };
                        } finally {
                          try {
                            if (references_3_1 && !references_3_1.done && (_c2 = references_3.return)) _c2.call(references_3);
                          } finally {
                            if (e_6) throw e_6.error;
                          }
                        }
                      }
                      return false;
                    }
                  }
                } else if (name === "useTransition") {
                  if (id2.type === "ArrayPattern" && id2.elements.length === 2 && Array.isArray(resolved2.identifiers)) {
                    if (id2.elements[1] === resolved2.identifiers[0]) {
                      return true;
                    }
                  }
                }
                return false;
              }
              function isFunctionWithoutCapturedValues(resolved2) {
                var e_7, _a2, e_8, _b2;
                if (!isArray(resolved2.defs)) {
                  return false;
                }
                var def2 = resolved2.defs[0];
                if (def2 == null) {
                  return false;
                }
                if (def2.node == null || def2.node.id == null) {
                  return false;
                }
                var fnNode = def2.node;
                var childScopes = (componentScope === null || componentScope === void 0 ? void 0 : componentScope.childScopes) || [];
                var fnScope = null;
                try {
                  for (var childScopes_1 = __values(childScopes), childScopes_1_1 = childScopes_1.next(); !childScopes_1_1.done; childScopes_1_1 = childScopes_1.next()) {
                    var childScope = childScopes_1_1.value;
                    var childScopeBlock = childScope.block;
                    if (
                      // function handleChange() {}
                      fnNode.type === "FunctionDeclaration" && childScopeBlock === fnNode || // const handleChange = () => {}
                      // const handleChange = function() {}
                      fnNode.type === "VariableDeclarator" && childScopeBlock.parent === fnNode
                    ) {
                      fnScope = childScope;
                      break;
                    }
                  }
                } catch (e_7_1) {
                  e_7 = { error: e_7_1 };
                } finally {
                  try {
                    if (childScopes_1_1 && !childScopes_1_1.done && (_a2 = childScopes_1.return)) _a2.call(childScopes_1);
                  } finally {
                    if (e_7) throw e_7.error;
                  }
                }
                if (fnScope == null) {
                  return false;
                }
                try {
                  for (var _c2 = __values(fnScope.through), _d2 = _c2.next(); !_d2.done; _d2 = _c2.next()) {
                    var ref2 = _d2.value;
                    if (ref2.resolved == null) {
                      continue;
                    }
                    if (pureScopes.has(ref2.resolved.scope) && // Stable values are fine though,
                    // although we won't check functions deeper.
                    !memoizedIsStableKnownHookValue(ref2.resolved)) {
                      return false;
                    }
                  }
                } catch (e_8_1) {
                  e_8 = { error: e_8_1 };
                } finally {
                  try {
                    if (_d2 && !_d2.done && (_b2 = _c2.return)) _b2.call(_c2);
                  } finally {
                    if (e_8) throw e_8.error;
                  }
                }
                return true;
              }
              var memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);
              var memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache);
              var currentRefsInEffectCleanup = /* @__PURE__ */ new Map();
              function isInsideEffectCleanup(reference2) {
                var curScope = reference2.from;
                var isInReturnedFunction = false;
                while (curScope != null && curScope.block !== node) {
                  if (curScope.type === "function") {
                    isInReturnedFunction = curScope.block.parent != null && curScope.block.parent.type === "ReturnStatement";
                  }
                  curScope = curScope.upper;
                }
                return isInReturnedFunction;
              }
              var dependencies = /* @__PURE__ */ new Map();
              var optionalChains = /* @__PURE__ */ new Map();
              gatherDependenciesRecursively(scope);
              function gatherDependenciesRecursively(currentScope2) {
                var e_9, _a2, e_10, _b2;
                var _c2, _d2, _e, _f, _g;
                try {
                  for (var _h = __values(currentScope2.references), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var reference2 = _j.value;
                    if (!reference2.resolved) {
                      continue;
                    }
                    if (!pureScopes.has(reference2.resolved.scope)) {
                      continue;
                    }
                    var referenceNode = fastFindReferenceWithParent(node, reference2.identifier);
                    if (referenceNode == null) {
                      continue;
                    }
                    var dependencyNode = getDependency(referenceNode);
                    var dependency = analyzePropertyChain(dependencyNode, optionalChains);
                    if (
                      // We're in an effect...
                      isEffect && // ... and this look like accessing .current...
                      dependencyNode.type === "Identifier" && (((_c2 = dependencyNode.parent) === null || _c2 === void 0 ? void 0 : _c2.type) === "MemberExpression" || ((_d2 = dependencyNode.parent) === null || _d2 === void 0 ? void 0 : _d2.type) === "OptionalMemberExpression") && !dependencyNode.parent.computed && dependencyNode.parent.property.type === "Identifier" && dependencyNode.parent.property.name === "current" && // ...in a cleanup function or below...
                      isInsideEffectCleanup(reference2)
                    ) {
                      currentRefsInEffectCleanup.set(dependency, {
                        reference: reference2,
                        dependencyNode
                      });
                    }
                    if (((_e = dependencyNode.parent) === null || _e === void 0 ? void 0 : _e.type) === "TSTypeQuery" || ((_f = dependencyNode.parent) === null || _f === void 0 ? void 0 : _f.type) === "TSTypeReference") {
                      continue;
                    }
                    var def2 = reference2.resolved.defs[0];
                    if (def2 == null) {
                      continue;
                    }
                    if (def2.node != null && def2.node.init === node.parent) {
                      continue;
                    }
                    if (def2.type === "TypeParameter") {
                      continue;
                    }
                    if (!dependencies.has(dependency)) {
                      var resolved2 = reference2.resolved;
                      var isStable = memoizedIsStableKnownHookValue(resolved2) || memoizedIsFunctionWithoutCapturedValues(resolved2);
                      dependencies.set(dependency, {
                        isStable,
                        references: [reference2]
                      });
                    } else {
                      (_g = dependencies.get(dependency)) === null || _g === void 0 ? void 0 : _g.references.push(reference2);
                    }
                  }
                } catch (e_9_1) {
                  e_9 = { error: e_9_1 };
                } finally {
                  try {
                    if (_j && !_j.done && (_a2 = _h.return)) _a2.call(_h);
                  } finally {
                    if (e_9) throw e_9.error;
                  }
                }
                try {
                  for (var _k = __values(currentScope2.childScopes), _l = _k.next(); !_l.done; _l = _k.next()) {
                    var childScope = _l.value;
                    gatherDependenciesRecursively(childScope);
                  }
                } catch (e_10_1) {
                  e_10 = { error: e_10_1 };
                } finally {
                  try {
                    if (_l && !_l.done && (_b2 = _k.return)) _b2.call(_k);
                  } finally {
                    if (e_10) throw e_10.error;
                  }
                }
              }
              currentRefsInEffectCleanup.forEach(function(_a2, dependency) {
                var e_11, _b2;
                var _c2, _d2;
                var reference2 = _a2.reference, dependencyNode = _a2.dependencyNode;
                var references2 = ((_c2 = reference2.resolved) === null || _c2 === void 0 ? void 0 : _c2.references) || [];
                var foundCurrentAssignment = false;
                try {
                  for (var references_4 = __values(references2), references_4_1 = references_4.next(); !references_4_1.done; references_4_1 = references_4.next()) {
                    var ref2 = references_4_1.value;
                    var identifier = ref2.identifier;
                    var parent2 = identifier.parent;
                    if (parent2 != null && // ref.current
                    // Note: no need to handle OptionalMemberExpression because it can't be LHS.
                    parent2.type === "MemberExpression" && !parent2.computed && parent2.property.type === "Identifier" && parent2.property.name === "current" && // ref.current = <something>
                    ((_d2 = parent2.parent) === null || _d2 === void 0 ? void 0 : _d2.type) === "AssignmentExpression" && parent2.parent.left === parent2) {
                      foundCurrentAssignment = true;
                      break;
                    }
                  }
                } catch (e_11_1) {
                  e_11 = { error: e_11_1 };
                } finally {
                  try {
                    if (references_4_1 && !references_4_1.done && (_b2 = references_4.return)) _b2.call(references_4);
                  } finally {
                    if (e_11) throw e_11.error;
                  }
                }
                if (foundCurrentAssignment) {
                  return;
                }
                reportProblem({
                  // @ts-expect-error We can do better here (dependencyNode.parent has not been type narrowed)
                  node: dependencyNode.parent.property,
                  message: "The ref value '".concat(dependency, ".current' will likely have ") + "changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy " + "'".concat(dependency, ".current' to a variable inside the effect, and ") + "use that variable in the cleanup function."
                });
              });
              var staleAssignments = /* @__PURE__ */ new Set();
              function reportStaleAssignment(writeExpr, key) {
                if (staleAssignments.has(key)) {
                  return;
                }
                staleAssignments.add(key);
                reportProblem({
                  node: writeExpr,
                  message: "Assignments to the '".concat(key, "' variable from inside React Hook ") + "".concat(getSourceCode().getText(reactiveHook), " will be lost after each ") + "render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside " + "".concat(getSourceCode().getText(reactiveHook), ".")
                });
              }
              var stableDependencies = /* @__PURE__ */ new Set();
              dependencies.forEach(function(_a2, key) {
                var isStable = _a2.isStable, references2 = _a2.references;
                if (isStable) {
                  stableDependencies.add(key);
                }
                references2.forEach(function(reference2) {
                  if (reference2.writeExpr) {
                    reportStaleAssignment(reference2.writeExpr, key);
                  }
                });
              });
              if (staleAssignments.size > 0) {
                return;
              }
              if (!declaredDependenciesNode) {
                var setStateInsideEffectWithoutDeps_1 = null;
                dependencies.forEach(function(_a2, key) {
                  var references2 = _a2.references;
                  if (setStateInsideEffectWithoutDeps_1) {
                    return;
                  }
                  references2.forEach(function(reference2) {
                    if (setStateInsideEffectWithoutDeps_1) {
                      return;
                    }
                    var id2 = reference2.identifier;
                    var isSetState = setStateCallSites.has(id2);
                    if (!isSetState) {
                      return;
                    }
                    var fnScope = reference2.from;
                    while (fnScope != null && fnScope.type !== "function") {
                      fnScope = fnScope.upper;
                    }
                    var isDirectlyInsideEffect = (fnScope === null || fnScope === void 0 ? void 0 : fnScope.block) === node;
                    if (isDirectlyInsideEffect) {
                      setStateInsideEffectWithoutDeps_1 = key;
                    }
                  });
                });
                if (setStateInsideEffectWithoutDeps_1) {
                  var suggestedDependencies_1 = collectRecommendations({
                    dependencies,
                    declaredDependencies: [],
                    stableDependencies,
                    externalDependencies: /* @__PURE__ */ new Set(),
                    isEffect: true
                  }).suggestedDependencies;
                  reportProblem({
                    node: reactiveHook,
                    message: "React Hook ".concat(reactiveHookName, " contains a call to '").concat(setStateInsideEffectWithoutDeps_1, "'. ") + "Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [" + suggestedDependencies_1.join(", ") + "] as a second argument to the ".concat(reactiveHookName, " Hook."),
                    suggest: [
                      {
                        desc: "Add dependencies array: [".concat(suggestedDependencies_1.join(", "), "]"),
                        fix: function(fixer) {
                          return fixer.insertTextAfter(node, ", [".concat(suggestedDependencies_1.join(", "), "]"));
                        }
                      }
                    ]
                  });
                }
                return;
              }
              var declaredDependencies = [];
              var externalDependencies = /* @__PURE__ */ new Set();
              var isArrayExpression = declaredDependenciesNode.type === "ArrayExpression";
              var isTSAsArrayExpression = declaredDependenciesNode.type === "TSAsExpression" && declaredDependenciesNode.expression.type === "ArrayExpression";
              if (!isArrayExpression && !isTSAsArrayExpression) {
                reportProblem({
                  node: declaredDependenciesNode,
                  message: "React Hook ".concat(getSourceCode().getText(reactiveHook), " was passed a ") + "dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."
                });
              } else {
                var arrayExpression = isTSAsArrayExpression ? declaredDependenciesNode.expression : declaredDependenciesNode;
                arrayExpression.elements.forEach(function(declaredDependencyNode) {
                  if (declaredDependencyNode === null) {
                    return;
                  }
                  if (declaredDependencyNode.type === "SpreadElement") {
                    reportProblem({
                      node: declaredDependencyNode,
                      message: "React Hook ".concat(getSourceCode().getText(reactiveHook), " has a spread ") + "element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."
                    });
                    return;
                  }
                  if (useEffectEventVariables.has(declaredDependencyNode)) {
                    reportProblem({
                      node: declaredDependencyNode,
                      message: "Functions returned from `useEffectEvent` must not be included in the dependency array. " + "Remove `".concat(getSourceCode().getText(declaredDependencyNode), "` from the list."),
                      suggest: [
                        {
                          desc: "Remove the dependency `".concat(getSourceCode().getText(declaredDependencyNode), "`"),
                          fix: function(fixer) {
                            return fixer.removeRange(declaredDependencyNode.range);
                          }
                        }
                      ]
                    });
                  }
                  var declaredDependency;
                  try {
                    declaredDependency = analyzePropertyChain(declaredDependencyNode, null);
                  } catch (error) {
                    if (error instanceof Error && /Unsupported node type/.test(error.message)) {
                      if (declaredDependencyNode.type === "Literal") {
                        if (declaredDependencyNode.value && dependencies.has(declaredDependencyNode.value)) {
                          reportProblem({
                            node: declaredDependencyNode,
                            message: "The ".concat(declaredDependencyNode.raw, " literal is not a valid dependency ") + "because it never changes. " + "Did you mean to include ".concat(declaredDependencyNode.value, " in the array instead?")
                          });
                        } else {
                          reportProblem({
                            node: declaredDependencyNode,
                            message: "The ".concat(declaredDependencyNode.raw, " literal is not a valid dependency ") + "because it never changes. You can safely remove it."
                          });
                        }
                      } else {
                        reportProblem({
                          node: declaredDependencyNode,
                          message: "React Hook ".concat(getSourceCode().getText(reactiveHook), " has a ") + "complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."
                        });
                      }
                      return;
                    } else {
                      throw error;
                    }
                  }
                  var maybeID = declaredDependencyNode;
                  while (maybeID.type === "MemberExpression" || maybeID.type === "OptionalMemberExpression" || maybeID.type === "ChainExpression") {
                    maybeID = maybeID.object || maybeID.expression.object;
                  }
                  var isDeclaredInComponent = !componentScope.through.some(function(ref2) {
                    return ref2.identifier === maybeID;
                  });
                  declaredDependencies.push({
                    key: declaredDependency,
                    node: declaredDependencyNode
                  });
                  if (!isDeclaredInComponent) {
                    externalDependencies.add(declaredDependency);
                  }
                });
              }
              var _d = collectRecommendations({
                dependencies,
                declaredDependencies,
                stableDependencies,
                externalDependencies,
                isEffect
              }), suggestedDependencies = _d.suggestedDependencies, unnecessaryDependencies = _d.unnecessaryDependencies, missingDependencies = _d.missingDependencies, duplicateDependencies = _d.duplicateDependencies;
              var suggestedDeps = suggestedDependencies;
              var problemCount = duplicateDependencies.size + missingDependencies.size + unnecessaryDependencies.size;
              if (problemCount === 0) {
                var constructions = scanForConstructions({
                  declaredDependencies,
                  declaredDependenciesNode,
                  componentScope,
                  scope
                });
                constructions.forEach(function(_a2) {
                  var _b2;
                  var construction = _a2.construction, isUsedOutsideOfHook = _a2.isUsedOutsideOfHook, depType = _a2.depType;
                  var wrapperHook = depType === "function" ? "useCallback" : "useMemo";
                  var constructionType = depType === "function" ? "definition" : "initialization";
                  var defaultAdvice = "wrap the ".concat(constructionType, " of '").concat(construction.name.name, "' in its own ").concat(wrapperHook, "() Hook.");
                  var advice = isUsedOutsideOfHook ? "To fix this, ".concat(defaultAdvice) : "Move it inside the ".concat(reactiveHookName, " callback. Alternatively, ").concat(defaultAdvice);
                  var causation = depType === "conditional" || depType === "logical expression" ? "could make" : "makes";
                  var message = "The '".concat(construction.name.name, "' ").concat(depType, " ").concat(causation, " the dependencies of ") + "".concat(reactiveHookName, " Hook (at line ").concat((_b2 = declaredDependenciesNode.loc) === null || _b2 === void 0 ? void 0 : _b2.start.line, ") ") + "change on every render. ".concat(advice);
                  var suggest;
                  if (isUsedOutsideOfHook && construction.type === "Variable" && // Objects may be mutated after construction, which would make this
                  // fix unsafe. Functions _probably_ won't be mutated, so we'll
                  // allow this fix for them.
                  depType === "function") {
                    suggest = [
                      {
                        desc: "Wrap the ".concat(constructionType, " of '").concat(construction.name.name, "' in its own ").concat(wrapperHook, "() Hook."),
                        fix: function(fixer) {
                          var _a3 = __read(wrapperHook === "useMemo" ? ["useMemo(() => { return ", "; })"] : ["useCallback(", ")"], 2), before = _a3[0], after = _a3[1];
                          return [
                            // TODO: also add an import?
                            fixer.insertTextBefore(construction.node.init, before),
                            // TODO: ideally we'd gather deps here but it would require
                            // restructuring the rule code. This will cause a new lint
                            // error to appear immediately for useCallback. Note we're
                            // not adding [] because would that changes semantics.
                            fixer.insertTextAfter(construction.node.init, after)
                          ];
                        }
                      }
                    ];
                  }
                  reportProblem({
                    // TODO: Why not report this at the dependency site?
                    node: construction.node,
                    message,
                    suggest
                  });
                });
                return;
              }
              if (!isEffect && missingDependencies.size > 0) {
                suggestedDeps = collectRecommendations({
                  dependencies,
                  declaredDependencies: [],
                  // Pretend we don't know
                  stableDependencies,
                  externalDependencies,
                  isEffect
                }).suggestedDependencies;
              }
              function areDeclaredDepsAlphabetized() {
                if (declaredDependencies.length === 0) {
                  return true;
                }
                var declaredDepKeys = declaredDependencies.map(function(dep2) {
                  return dep2.key;
                });
                var sortedDeclaredDepKeys = declaredDepKeys.slice().sort();
                return declaredDepKeys.join(",") === sortedDeclaredDepKeys.join(",");
              }
              if (areDeclaredDepsAlphabetized()) {
                suggestedDeps.sort();
              }
              function formatDependency(path) {
                var members = path.split(".");
                var finalPath = "";
                for (var i = 0; i < members.length; i++) {
                  if (i !== 0) {
                    var pathSoFar = members.slice(0, i + 1).join(".");
                    var isOptional = optionalChains.get(pathSoFar) === true;
                    finalPath += isOptional ? "?." : ".";
                  }
                  finalPath += members[i];
                }
                return finalPath;
              }
              function getWarningMessage(deps, singlePrefix, label, fixVerb) {
                if (deps.size === 0) {
                  return null;
                }
                return (deps.size > 1 ? "" : singlePrefix + " ") + label + " " + (deps.size > 1 ? "dependencies" : "dependency") + ": " + joinEnglish(Array.from(deps).sort().map(function(name) {
                  return "'" + formatDependency(name) + "'";
                })) + ". Either ".concat(fixVerb, " ").concat(deps.size > 1 ? "them" : "it", " or remove the dependency array.");
              }
              var extraWarning = "";
              if (unnecessaryDependencies.size > 0) {
                var badRef_1 = null;
                Array.from(unnecessaryDependencies.keys()).forEach(function(key) {
                  if (badRef_1 !== null) {
                    return;
                  }
                  if (key.endsWith(".current")) {
                    badRef_1 = key;
                  }
                });
                if (badRef_1 !== null) {
                  extraWarning = " Mutable values like '".concat(badRef_1, "' aren't valid dependencies ") + "because mutating them doesn't re-render the component.";
                } else if (externalDependencies.size > 0) {
                  var dep = Array.from(externalDependencies)[0];
                  if (!scope.set.has(dep)) {
                    extraWarning = " Outer scope values like '".concat(dep, "' aren't valid dependencies ") + "because mutating them doesn't re-render the component.";
                  }
                }
              }
              if (!extraWarning && missingDependencies.has("props")) {
                var propDep = dependencies.get("props");
                if (propDep == null) {
                  return;
                }
                var refs = propDep.references;
                if (!Array.isArray(refs)) {
                  return;
                }
                var isPropsOnlyUsedInMembers = true;
                try {
                  for (var refs_1 = __values(refs), refs_1_1 = refs_1.next(); !refs_1_1.done; refs_1_1 = refs_1.next()) {
                    var ref = refs_1_1.value;
                    var id = fastFindReferenceWithParent(componentScope.block, ref.identifier);
                    if (!id) {
                      isPropsOnlyUsedInMembers = false;
                      break;
                    }
                    var parent = id.parent;
                    if (parent == null) {
                      isPropsOnlyUsedInMembers = false;
                      break;
                    }
                    if (parent.type !== "MemberExpression" && parent.type !== "OptionalMemberExpression") {
                      isPropsOnlyUsedInMembers = false;
                      break;
                    }
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (refs_1_1 && !refs_1_1.done && (_a = refs_1.return)) _a.call(refs_1);
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                if (isPropsOnlyUsedInMembers) {
                  extraWarning = " However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of " + "the ".concat(reactiveHookName, " call and refer to those specific props ") + "inside ".concat(getSourceCode().getText(reactiveHook), ".");
                }
              }
              if (!extraWarning && missingDependencies.size > 0) {
                var missingCallbackDep_1 = null;
                missingDependencies.forEach(function(missingDep2) {
                  var e_12, _a2;
                  var _b2;
                  if (missingCallbackDep_1) {
                    return;
                  }
                  var topScopeRef = componentScope.set.get(missingDep2);
                  var usedDep2 = dependencies.get(missingDep2);
                  if (!(usedDep2 === null || usedDep2 === void 0 ? void 0 : usedDep2.references) || ((_b2 = usedDep2 === null || usedDep2 === void 0 ? void 0 : usedDep2.references[0]) === null || _b2 === void 0 ? void 0 : _b2.resolved) !== topScopeRef) {
                    return;
                  }
                  var def2 = topScopeRef === null || topScopeRef === void 0 ? void 0 : topScopeRef.defs[0];
                  if (def2 == null || def2.name == null || def2.type !== "Parameter") {
                    return;
                  }
                  var isFunctionCall = false;
                  var id2;
                  try {
                    for (var _c2 = __values(usedDep2.references), _d2 = _c2.next(); !_d2.done; _d2 = _c2.next()) {
                      var reference2 = _d2.value;
                      id2 = reference2.identifier;
                      if (id2 != null && id2.parent != null && (id2.parent.type === "CallExpression" || id2.parent.type === "OptionalCallExpression") && id2.parent.callee === id2) {
                        isFunctionCall = true;
                        break;
                      }
                    }
                  } catch (e_12_1) {
                    e_12 = { error: e_12_1 };
                  } finally {
                    try {
                      if (_d2 && !_d2.done && (_a2 = _c2.return)) _a2.call(_c2);
                    } finally {
                      if (e_12) throw e_12.error;
                    }
                  }
                  if (!isFunctionCall) {
                    return;
                  }
                  missingCallbackDep_1 = missingDep2;
                });
                if (missingCallbackDep_1 !== null) {
                  extraWarning = " If '".concat(missingCallbackDep_1, "' changes too often, ") + "find the parent component that defines it and wrap that definition in useCallback.";
                }
              }
              if (!extraWarning && missingDependencies.size > 0) {
                var setStateRecommendation = null;
                try {
                  for (var missingDependencies_1 = __values(missingDependencies), missingDependencies_1_1 = missingDependencies_1.next(); !missingDependencies_1_1.done; missingDependencies_1_1 = missingDependencies_1.next()) {
                    var missingDep = missingDependencies_1_1.value;
                    if (setStateRecommendation !== null) {
                      break;
                    }
                    var usedDep = dependencies.get(missingDep);
                    var references = usedDep.references;
                    var id = void 0;
                    var maybeCall = void 0;
                    try {
                      for (var references_1 = (e_3 = void 0, __values(references)), references_1_1 = references_1.next(); !references_1_1.done; references_1_1 = references_1.next()) {
                        var reference = references_1_1.value;
                        id = reference.identifier;
                        maybeCall = id.parent;
                        while (maybeCall != null && maybeCall !== componentScope.block) {
                          if (maybeCall.type === "CallExpression") {
                            var correspondingStateVariable = setStateCallSites.get(maybeCall.callee);
                            if (correspondingStateVariable != null) {
                              if ("name" in correspondingStateVariable && correspondingStateVariable.name === missingDep) {
                                setStateRecommendation = {
                                  missingDep,
                                  setter: "name" in maybeCall.callee ? maybeCall.callee.name : "",
                                  form: "updater"
                                };
                              } else if (stateVariables.has(id)) {
                                setStateRecommendation = {
                                  missingDep,
                                  setter: "name" in maybeCall.callee ? maybeCall.callee.name : "",
                                  form: "reducer"
                                };
                              } else {
                                var resolved = reference.resolved;
                                if (resolved != null) {
                                  var def = resolved.defs[0];
                                  if (def != null && def.type === "Parameter") {
                                    setStateRecommendation = {
                                      missingDep,
                                      setter: "name" in maybeCall.callee ? maybeCall.callee.name : "",
                                      form: "inlineReducer"
                                    };
                                  }
                                }
                              }
                              break;
                            }
                          }
                          maybeCall = maybeCall.parent;
                        }
                        if (setStateRecommendation !== null) {
                          break;
                        }
                      }
                    } catch (e_3_1) {
                      e_3 = { error: e_3_1 };
                    } finally {
                      try {
                        if (references_1_1 && !references_1_1.done && (_c = references_1.return)) _c.call(references_1);
                      } finally {
                        if (e_3) throw e_3.error;
                      }
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (missingDependencies_1_1 && !missingDependencies_1_1.done && (_b = missingDependencies_1.return)) _b.call(missingDependencies_1);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                if (setStateRecommendation !== null) {
                  switch (setStateRecommendation.form) {
                    case "reducer":
                      extraWarning = " You can also replace multiple useState variables with useReducer " + "if '".concat(setStateRecommendation.setter, "' needs the ") + "current value of '".concat(setStateRecommendation.missingDep, "'.");
                      break;
                    case "inlineReducer":
                      extraWarning = " If '".concat(setStateRecommendation.setter, "' needs the ") + "current value of '".concat(setStateRecommendation.missingDep, "', ") + "you can also switch to useReducer instead of useState and " + "read '".concat(setStateRecommendation.missingDep, "' in the reducer.");
                      break;
                    case "updater":
                      extraWarning = " You can also do a functional update '".concat(setStateRecommendation.setter, "(").concat(setStateRecommendation.missingDep.slice(0, 1), " => ...)' if you only need '").concat(setStateRecommendation.missingDep, "'") + " in the '".concat(setStateRecommendation.setter, "' call.");
                      break;
                    default:
                      throw new Error("Unknown case.");
                  }
                }
              }
              reportProblem({
                node: declaredDependenciesNode,
                message: "React Hook ".concat(getSourceCode().getText(reactiveHook), " has ") + // To avoid a long message, show the next actionable item.
                (getWarningMessage(missingDependencies, "a", "missing", "include") || getWarningMessage(unnecessaryDependencies, "an", "unnecessary", "exclude") || getWarningMessage(duplicateDependencies, "a", "duplicate", "omit")) + extraWarning,
                suggest: [
                  {
                    desc: "Update the dependencies array to be: [".concat(suggestedDeps.map(formatDependency).join(", "), "]"),
                    fix: function(fixer) {
                      return fixer.replaceText(declaredDependenciesNode, "[".concat(suggestedDeps.map(formatDependency).join(", "), "]"));
                    }
                  }
                ]
              });
            }
            function visitCallExpression(node) {
              var callbackIndex = getReactiveHookCallbackIndex(node.callee, options);
              if (callbackIndex === -1) {
                return;
              }
              var callback = node.arguments[callbackIndex];
              var reactiveHook = node.callee;
              var nodeWithoutNamespace = getNodeWithoutReactNamespace(reactiveHook);
              var reactiveHookName = "name" in nodeWithoutNamespace ? nodeWithoutNamespace.name : "";
              var maybeNode = node.arguments[callbackIndex + 1];
              var declaredDependenciesNode = maybeNode && !(maybeNode.type === "Identifier" && maybeNode.name === "undefined") ? maybeNode : void 0;
              var isEffect = /Effect($|[^a-z])/g.test(reactiveHookName);
              if (!callback) {
                reportProblem({
                  node: reactiveHook,
                  message: "React Hook ".concat(reactiveHookName, " requires an effect callback. ") + "Did you forget to pass a callback to the hook?"
                });
                return;
              }
              if (!declaredDependenciesNode && !isEffect) {
                if (reactiveHookName === "useMemo" || reactiveHookName === "useCallback") {
                  reportProblem({
                    node: reactiveHook,
                    message: "React Hook ".concat(reactiveHookName, " does nothing when called with ") + "only one argument. Did you forget to pass an array of dependencies?"
                  });
                }
                return;
              }
              while (callback.type === "TSAsExpression" || callback.type === "AsExpression") {
                callback = callback.expression;
              }
              switch (callback.type) {
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                  visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);
                  return;
                // Handled
                case "Identifier":
                  if (!declaredDependenciesNode) {
                    return;
                  }
                  if ("elements" in declaredDependenciesNode && declaredDependenciesNode.elements && declaredDependenciesNode.elements.some(function(el) {
                    return el && el.type === "Identifier" && el.name === callback.name;
                  })) {
                    return;
                  }
                  var variable = getScope(callback).set.get(callback.name);
                  if (variable == null || variable.defs == null) {
                    return;
                  }
                  var def = variable.defs[0];
                  if (!def || !def.node) {
                    break;
                  }
                  if (def.type === "Parameter") {
                    reportProblem({
                      node: reactiveHook,
                      message: getUnknownDependenciesMessage(reactiveHookName)
                    });
                    return;
                  }
                  if (def.type !== "Variable" && def.type !== "FunctionName") {
                    break;
                  }
                  switch (def.node.type) {
                    case "FunctionDeclaration":
                      visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);
                      return;
                    // Handled
                    case "VariableDeclarator":
                      var init = def.node.init;
                      if (!init) {
                        break;
                      }
                      switch (init.type) {
                        // const effectBody = () => {...};
                        // useEffect(effectBody, []);
                        case "ArrowFunctionExpression":
                        case "FunctionExpression":
                          visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);
                          return;
                      }
                      break;
                  }
                  break;
                // Unhandled
                default:
                  reportProblem({
                    node: reactiveHook,
                    message: getUnknownDependenciesMessage(reactiveHookName)
                  });
                  return;
              }
              reportProblem({
                node: reactiveHook,
                message: "React Hook ".concat(reactiveHookName, " has a missing dependency: '").concat(callback.name, "'. ") + "Either include it or remove the dependency array.",
                suggest: [
                  {
                    desc: "Update the dependencies array to be: [".concat(callback.name, "]"),
                    fix: function(fixer) {
                      return fixer.replaceText(declaredDependenciesNode, "[".concat(callback.name, "]"));
                    }
                  }
                ]
              });
            }
            return {
              CallExpression: visitCallExpression
            };
          }
        };
        function collectRecommendations(_a) {
          var dependencies = _a.dependencies, declaredDependencies = _a.declaredDependencies, stableDependencies = _a.stableDependencies, externalDependencies = _a.externalDependencies, isEffect = _a.isEffect;
          var depTree = createDepTree();
          function createDepTree() {
            return {
              isUsed: false,
              // True if used in code
              isSatisfiedRecursively: false,
              // True if specified in deps
              isSubtreeUsed: false,
              // True if something deeper is used by code
              children: /* @__PURE__ */ new Map()
              // Nodes for properties
            };
          }
          dependencies.forEach(function(_, key) {
            var node = getOrCreateNodeByPath(depTree, key);
            node.isUsed = true;
            markAllParentsByPath(depTree, key, function(parent) {
              parent.isSubtreeUsed = true;
            });
          });
          declaredDependencies.forEach(function(_a2) {
            var key = _a2.key;
            var node = getOrCreateNodeByPath(depTree, key);
            node.isSatisfiedRecursively = true;
          });
          stableDependencies.forEach(function(key) {
            var node = getOrCreateNodeByPath(depTree, key);
            node.isSatisfiedRecursively = true;
          });
          function getOrCreateNodeByPath(rootNode, path) {
            var e_13, _a2;
            var keys = path.split(".");
            var node = rootNode;
            try {
              for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                var child = node.children.get(key);
                if (!child) {
                  child = createDepTree();
                  node.children.set(key, child);
                }
                node = child;
              }
            } catch (e_13_1) {
              e_13 = { error: e_13_1 };
            } finally {
              try {
                if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return)) _a2.call(keys_1);
              } finally {
                if (e_13) throw e_13.error;
              }
            }
            return node;
          }
          function markAllParentsByPath(rootNode, path, fn) {
            var e_14, _a2;
            var keys = path.split(".");
            var node = rootNode;
            try {
              for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                var key = keys_2_1.value;
                var child = node.children.get(key);
                if (!child) {
                  return;
                }
                fn(child);
                node = child;
              }
            } catch (e_14_1) {
              e_14 = { error: e_14_1 };
            } finally {
              try {
                if (keys_2_1 && !keys_2_1.done && (_a2 = keys_2.return)) _a2.call(keys_2);
              } finally {
                if (e_14) throw e_14.error;
              }
            }
          }
          var missingDependencies = /* @__PURE__ */ new Set();
          var satisfyingDependencies = /* @__PURE__ */ new Set();
          scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, function(key) {
            return key;
          });
          function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {
            node.children.forEach(function(child, key) {
              var path = keyToPath(key);
              if (child.isSatisfiedRecursively) {
                if (child.isSubtreeUsed) {
                  satisfyingPaths.add(path);
                }
                return;
              }
              if (child.isUsed) {
                missingPaths.add(path);
                return;
              }
              scanTreeRecursively(child, missingPaths, satisfyingPaths, function(childKey) {
                return path + "." + childKey;
              });
            });
          }
          var suggestedDependencies = [];
          var unnecessaryDependencies = /* @__PURE__ */ new Set();
          var duplicateDependencies = /* @__PURE__ */ new Set();
          declaredDependencies.forEach(function(_a2) {
            var key = _a2.key;
            if (satisfyingDependencies.has(key)) {
              if (suggestedDependencies.indexOf(key) === -1) {
                suggestedDependencies.push(key);
              } else {
                duplicateDependencies.add(key);
              }
            } else {
              if (isEffect && !key.endsWith(".current") && !externalDependencies.has(key)) {
                if (suggestedDependencies.indexOf(key) === -1) {
                  suggestedDependencies.push(key);
                }
              } else {
                unnecessaryDependencies.add(key);
              }
            }
          });
          missingDependencies.forEach(function(key) {
            suggestedDependencies.push(key);
          });
          return {
            suggestedDependencies,
            unnecessaryDependencies,
            duplicateDependencies,
            missingDependencies
          };
        }
        function getConstructionExpressionType(node) {
          switch (node.type) {
            case "ObjectExpression":
              return "object";
            case "ArrayExpression":
              return "array";
            case "ArrowFunctionExpression":
            case "FunctionExpression":
              return "function";
            case "ClassExpression":
              return "class";
            case "ConditionalExpression":
              if (getConstructionExpressionType(node.consequent) != null || getConstructionExpressionType(node.alternate) != null) {
                return "conditional";
              }
              return null;
            case "LogicalExpression":
              if (getConstructionExpressionType(node.left) != null || getConstructionExpressionType(node.right) != null) {
                return "logical expression";
              }
              return null;
            case "JSXFragment":
              return "JSX fragment";
            case "JSXElement":
              return "JSX element";
            case "AssignmentExpression":
              if (getConstructionExpressionType(node.right) != null) {
                return "assignment expression";
              }
              return null;
            case "NewExpression":
              return "object construction";
            case "Literal":
              if (node.value instanceof RegExp) {
                return "regular expression";
              }
              return null;
            case "TypeCastExpression":
            case "AsExpression":
            case "TSAsExpression":
              return getConstructionExpressionType(node.expression);
          }
          return null;
        }
        function scanForConstructions(_a) {
          var declaredDependencies = _a.declaredDependencies, declaredDependenciesNode = _a.declaredDependenciesNode, componentScope = _a.componentScope, scope = _a.scope;
          var constructions = declaredDependencies.map(function(_a2) {
            var key = _a2.key;
            var ref = componentScope.variables.find(function(v) {
              return v.name === key;
            });
            if (ref == null) {
              return null;
            }
            var node = ref.defs[0];
            if (node == null) {
              return null;
            }
            if (node.type === "Variable" && node.node.type === "VariableDeclarator" && node.node.id.type === "Identifier" && // Ensure this is not destructed assignment
            node.node.init != null) {
              var constantExpressionType = getConstructionExpressionType(node.node.init);
              if (constantExpressionType) {
                return [ref, constantExpressionType];
              }
            }
            if (node.type === "FunctionName" && node.node.type === "FunctionDeclaration") {
              return [ref, "function"];
            }
            if (node.type === "ClassName" && node.node.type === "ClassDeclaration") {
              return [ref, "class"];
            }
            return null;
          }).filter(Boolean);
          function isUsedOutsideOfHook(ref) {
            var e_15, _a2;
            var foundWriteExpr = false;
            try {
              for (var _b = __values(ref.references), _c = _b.next(); !_c.done; _c = _b.next()) {
                var reference = _c.value;
                if (reference.writeExpr) {
                  if (foundWriteExpr) {
                    return true;
                  } else {
                    foundWriteExpr = true;
                    continue;
                  }
                }
                var currentScope = reference.from;
                while (currentScope !== scope && currentScope != null) {
                  currentScope = currentScope.upper;
                }
                if (currentScope !== scope) {
                  if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {
                    return true;
                  }
                }
              }
            } catch (e_15_1) {
              e_15 = { error: e_15_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
              } finally {
                if (e_15) throw e_15.error;
              }
            }
            return false;
          }
          return constructions.map(function(_a2) {
            var _b = __read(_a2, 2), ref = _b[0], depType = _b[1];
            return {
              construction: ref.defs[0],
              depType,
              isUsedOutsideOfHook: isUsedOutsideOfHook(ref)
            };
          });
        }
        function getDependency(node) {
          if (node.parent && (node.parent.type === "MemberExpression" || node.parent.type === "OptionalMemberExpression") && node.parent.object === node && "name" in node.parent.property && node.parent.property.name !== "current" && !node.parent.computed && !(node.parent.parent != null && (node.parent.parent.type === "CallExpression" || node.parent.parent.type === "OptionalCallExpression") && node.parent.parent.callee === node.parent)) {
            return getDependency(node.parent);
          } else if (
            // Note: we don't check OptionalMemberExpression because it can't be LHS.
            node.type === "MemberExpression" && node.parent && node.parent.type === "AssignmentExpression" && node.parent.left === node
          ) {
            return node.object;
          } else {
            return node;
          }
        }
        function markNode(node, optionalChains, result) {
          if (optionalChains) {
            if ("optional" in node && node.optional) {
              if (!optionalChains.has(result)) {
                optionalChains.set(result, true);
              }
            } else {
              optionalChains.set(result, false);
            }
          }
        }
        function analyzePropertyChain(node, optionalChains) {
          if (node.type === "Identifier" || node.type === "JSXIdentifier") {
            var result = node.name;
            if (optionalChains) {
              optionalChains.set(result, false);
            }
            return result;
          } else if (node.type === "MemberExpression" && !node.computed) {
            var object = analyzePropertyChain(node.object, optionalChains);
            var property = analyzePropertyChain(node.property, null);
            var result = "".concat(object, ".").concat(property);
            markNode(node, optionalChains, result);
            return result;
          } else if (node.type === "OptionalMemberExpression" && !node.computed) {
            var object = analyzePropertyChain(node.object, optionalChains);
            var property = analyzePropertyChain(node.property, null);
            var result = "".concat(object, ".").concat(property);
            markNode(node, optionalChains, result);
            return result;
          } else if (node.type === "ChainExpression" && (!("computed" in node) || !node.computed)) {
            var expression = node.expression;
            if (expression.type === "CallExpression") {
              throw new Error("Unsupported node type: ".concat(expression.type));
            }
            var object = analyzePropertyChain(expression.object, optionalChains);
            var property = analyzePropertyChain(expression.property, null);
            var result = "".concat(object, ".").concat(property);
            markNode(expression, optionalChains, result);
            return result;
          } else {
            throw new Error("Unsupported node type: ".concat(node.type));
          }
        }
        function getNodeWithoutReactNamespace(node) {
          if (node.type === "MemberExpression" && node.object.type === "Identifier" && node.object.name === "React" && node.property.type === "Identifier" && !node.computed) {
            return node.property;
          }
          return node;
        }
        function getReactiveHookCallbackIndex(calleeNode, options) {
          var node = getNodeWithoutReactNamespace(calleeNode);
          if (node.type !== "Identifier") {
            return -1;
          }
          switch (node.name) {
            case "useEffect":
            case "useLayoutEffect":
            case "useCallback":
            case "useMemo":
              return 0;
            case "useImperativeHandle":
              return 1;
            default:
              if (node === calleeNode && options && options.additionalHooks) {
                var name = void 0;
                try {
                  name = analyzePropertyChain(node, null);
                } catch (error) {
                  if (error instanceof Error && /Unsupported node type/.test(error.message)) {
                    return 0;
                  } else {
                    throw error;
                  }
                }
                return options.additionalHooks.test(name) ? 0 : -1;
              } else {
                return -1;
              }
          }
        }
        function fastFindReferenceWithParent(start, target) {
          var e_16, _a;
          var queue = [start];
          var item;
          while (queue.length) {
            item = queue.shift();
            if (isSameIdentifier(item, target)) {
              return item;
            }
            if (!isAncestorNodeOf(item, target)) {
              continue;
            }
            try {
              for (var _b = (e_16 = void 0, __values(Object.entries(item))), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                if (key === "parent") {
                  continue;
                }
                if (isNodeLike(value)) {
                  value.parent = item;
                  queue.push(value);
                } else if (Array.isArray(value)) {
                  value.forEach(function(val) {
                    if (isNodeLike(val)) {
                      val.parent = item;
                      queue.push(val);
                    }
                  });
                }
              }
            } catch (e_16_1) {
              e_16 = { error: e_16_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              } finally {
                if (e_16) throw e_16.error;
              }
            }
          }
          return null;
        }
        function joinEnglish(arr) {
          var s = "";
          for (var i = 0; i < arr.length; i++) {
            s += arr[i];
            if (i === 0 && arr.length === 2) {
              s += " and ";
            } else if (i === arr.length - 2 && arr.length > 2) {
              s += ", and ";
            } else if (i < arr.length - 1) {
              s += ", ";
            }
          }
          return s;
        }
        function isNodeLike(val) {
          return typeof val === "object" && val !== null && !Array.isArray(val) && "type" in val && typeof val.type === "string";
        }
        function isSameIdentifier(a, b) {
          return (a.type === "Identifier" || a.type === "JSXIdentifier") && a.type === b.type && a.name === b.name && !!a.range && !!b.range && a.range[0] === b.range[0] && a.range[1] === b.range[1];
        }
        function isAncestorNodeOf(a, b) {
          return !!a.range && !!b.range && a.range[0] <= b.range[0] && a.range[1] >= b.range[1];
        }
        function isUseEffectEventIdentifier(node) {
          return false;
        }
        function getUnknownDependenciesMessage(reactiveHookName) {
          return "React Hook ".concat(reactiveHookName, " received a function whose dependencies ") + "are unknown. Pass an inline function instead.";
        }
        var rules = {
          "rules-of-hooks": rule$1,
          "exhaustive-deps": rule
        };
        var configRules = {
          "react-hooks/rules-of-hooks": "error",
          "react-hooks/exhaustive-deps": "warn"
        };
        var legacyRecommendedConfig = {
          plugins: ["react-hooks"],
          rules: configRules
        };
        var plugin = {
          // TODO: Make this more dynamic to populate version from package.json.
          // This can be done by injecting at build time, since importing the package.json isn't an option in Meta
          meta: { name: "eslint-plugin-react-hooks" },
          rules,
          configs: {
            /** Legacy recommended config, to be used with rc-based configurations */
            "recommended-legacy": legacyRecommendedConfig,
            /**
             * 'recommended' is currently aliased to the legacy / rc recommended config) to maintain backwards compatibility.
             * This is deprecated and in v6, it will switch to alias the flat recommended config.
             */
            recommended: legacyRecommendedConfig,
            /** Latest recommended config, to be used with flat configurations */
            "recommended-latest": {
              name: "react-hooks/recommended",
              plugins: {
                get "react-hooks"() {
                  return plugin;
                }
              },
              rules: configRules
            }
          }
        };
        var configs = plugin.configs;
        var meta = plugin.meta;
        exports.configs = configs;
        exports.meta = meta;
        exports.rules = rules;
      })();
    }
  }
});

// node_modules/eslint-plugin-react-hooks/index.js
var require_eslint_plugin_react_hooks = __commonJS({
  "node_modules/eslint-plugin-react-hooks/index.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_eslint_plugin_react_hooks_development();
    }
  }
});
export default require_eslint_plugin_react_hooks();
/*! Bundled license information:

eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js:
  (**
   * @license React
   * eslint-plugin-react-hooks.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=eslint-plugin-react-hooks.js.map
